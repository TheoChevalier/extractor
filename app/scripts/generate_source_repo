#!/usr/bin/env php
<?php
namespace Transvision;

function sortByTimestamp($target, $commits, $name) {
    foreach ($commits as $commit) {
        $timestamp = $commit['date']->getTimestamp();

        // Handle edge case where two pushes occured at very same timestamp
        while(isset($target[$timestamp])) {
            $timestamp++;
        }
        $commit['repo'] = $name;
        $target[$timestamp] = $commit;
    }

    return $target;
}

function linkBugstoBugzilla($string) {
    $bugs = [];
    preg_match_all("/Bug ?([0-9]+)\b/i", $string, $bugs);

    $n = 0;
    foreach ($bugs[0] as $bug_as_string) {
        $bz_link = 'https://bugzil.la/' . $bugs[1][$n];
        $string = str_replace($bug_as_string, $bz_link, $string);
        $n++;
    }

    return $string;
}

if (php_sapi_name() != 'cli') {
    die('This command can only be used in CLI mode.');
}

if (count($argv) < 2) {
    die("This command needs more parameters, please check generate_source_repo --help.\n");
}
if (isset($argv[1])) {
    if (in_array($argv[1], ['-h', '--help'])) {
        $command_help = "generate_sources_repo - Creates repo with source strings only\n" .
                "Usage: generate_sources_repo [channel_name]\n\n" .
                "Example: generate_sources beta\n" .
                "Accepted values: central, aurora, beta, release\n";
        die($command_help);
    }
}

include __DIR__ . '/../inc/init.php';
include 'config/config_' . $argv[1] . '.php';

$tag_products = ['FIREFOX', 'FENNEC', 'THUNDERBIRD', 'SEAMONKEY'];

// Init target Git repo for storage
$target_repo_path = GIT . $target_repo;
if (! is_dir($target_repo_path)) {
    mkdir($target_repo_path);
}
$git = new DataManager($target_repo_path, $target_repo);

// Update hg repo
$moz_repo->update();
$comm_repo->update();

// Store hg history in each HgRepo object
$moz_repo->getHistory();
$comm_repo->getHistory();

print ("Got history\n");

$sorted_timestamps = [];
if (! empty($comm_repo->data)) {
    $sorted_timestamps = sortByTimestamp($sorted_timestamps, $comm_repo->data, $comm_repo->short_name);
    $comm_repo->data = [];
}
if (! empty($moz_repo->data)) {
    $sorted_timestamps = sortByTimestamp($sorted_timestamps, $moz_repo->data, $moz_repo->short_name);
    $moz_repo->data = [];
}
ksort($sorted_timestamps);

print ("Start committing\n");

foreach ($sorted_timestamps as $commit) {
    $l10n_has_changed = false;
    $rev = explode(':', $commit['commit'])[1];

    $vcs = $moz_repo;
    if ($commit['repo'] == $comm_repo->short_name) {
        $vcs = $comm_repo;
    }

    $vcs->rev = $rev;
    $changes = $vcs->getChangedFiles($rev);
    $first_change = true;
    foreach ($changes as $change) {
        // Quick check to eliminate files outside l10n directories
        if (! Strings::startsWith($change['path'], array_keys($vcs->repo_dirs))) {
            continue;
        }

        if ($first_change) {
            // Checkout the repo to the current revision
            $first_change = false;
            $vcs->revertRepo($rev);
        }
        $l10n_has_changed = true;

        // Get from which source directory the file is coming
        foreach ($vcs->repo_dirs as $source => $target) {
            if (Strings::startsWith($change['path'], $source)) {
                $source_dir = $source;
                $target_dir = $target;
            }
        }

        // Build target path by switching dirs and adding target repo
        $target_path = str_replace($source_dir, $target_dir, $change['path']);
        $target_path = $target_repo_path . '/' . $target_path;

        // Check the type of change and copy / delete the file to/from target repo
        switch($change['type']) {
            case 'A':
            case 'M':
                Files::fileForceContents(
                    $target_path,
                    file_get_contents($vcs->repository_path . '/' . $change['path'])
                );
                break;
            case 'R':
                /*
                    Remove the file only if it exists (merges are listing
                    already deleted files)
                */
                if (is_file($target_path)) {
                    unlink($target_path);
                }
                break;
        }
    }

    // Skip tags on comm-* repos
    if ($vcs->short_name == $moz_repo->short_name) {
        foreach ($commit['tags'] as $tag) {
            $exploded_tag = explode('_', $tag);

            // Only keep tags for major releases
            if (in_array($exploded_tag[0], $tag_products) && $exploded_tag[2] == '0' && $exploded_tag[3] == 'RELEASE') {
                // TODO: Handle special case of SeaMonkey version number
                $git->tag($tag);
            }
        }
    }

    /*
        If this commit has l10n files listed in its changed files and actually
        changed those files, record it
    */
    if ($l10n_has_changed && ! empty($git->status())) {
        $commit['summary'] = linkBugstoBugzilla($commit['summary']);
        $message = $commit['summary'] . "\n\nDiff on {$vcs->origin}: https://hg.mozilla.org/{$vcs->web_link}/rev/{$rev}";
        $author  = $commit['author'] . ' <' . $commit['email'] . '>';
        $date    = $commit['date']->format('D M j H:i:s Y O');

        $cwd = getcwd();
        chdir($git->repository_path);
        shell_exec("git config user.name \"{$commit['author']}\"");
        shell_exec("git config user.email \"{$commit['email']}\"");
        chdir($cwd);

        $git->commit($message, $author, $date);
    }
}

$cwd = getcwd();
chdir($git->repository_path);
shell_exec("{$cwd}/app/scripts/update_committer_date.sh");
chdir($cwd);

$git->push();

if (isset($moz_repo->rev)) {
    file_put_contents($moz_repo->save_latest, $moz_repo->rev);
}
if (isset($comm_repo->rev)) {
    file_put_contents($comm_repo->save_latest, $comm_repo->rev);
}
